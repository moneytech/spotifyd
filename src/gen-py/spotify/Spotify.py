#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  def loginSession(self, cred):
    """
    Parameters:
     - cred
    """
    pass

  def isLoggedIn(self, cred):
    """
    Parameters:
     - cred
    """
    pass

  def logoutSession(self, cred):
    """
    Parameters:
     - cred
    """
    pass

  def sendCommand(self, cred, cmd):
    """
    Parameters:
     - cred
     - cmd
    """
    pass

  def search(self, cred, criteria):
    """
    Parameters:
     - cred
     - criteria
    """
    pass

  def getPlaylists(self, cred):
    """
    Parameters:
     - cred
    """
    pass

  def getPlaylist(self, cred, plist_id):
    """
    Parameters:
     - cred
     - plist_id
    """
    pass

  def getPlaylistByName(self, cred, name):
    """
    Parameters:
     - cred
     - name
    """
    pass

  def selectPlaylist(self, cred, playlist):
    """
    Parameters:
     - cred
     - playlist
    """
    pass

  def selectPlaylistById(self, cred, plist_id):
    """
    Parameters:
     - cred
     - plist_id
    """
    pass

  def merge2playlist(self, cred, pl, tracks):
    """
    Parameters:
     - cred
     - pl
     - tracks
    """
    pass

  def add2playlist(self, cred, pl, track):
    """
    Parameters:
     - cred
     - pl
     - track
    """
    pass

  def whats_playing(self, ):
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def loginSession(self, cred):
    """
    Parameters:
     - cred
    """
    self.send_loginSession(cred)
    return self.recv_loginSession()

  def send_loginSession(self, cred):
    self._oprot.writeMessageBegin('loginSession', TMessageType.CALL, self._seqid)
    args = loginSession_args()
    args.cred = cred
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_loginSession(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = loginSession_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "loginSession failed: unknown result");

  def isLoggedIn(self, cred):
    """
    Parameters:
     - cred
    """
    self.send_isLoggedIn(cred)
    return self.recv_isLoggedIn()

  def send_isLoggedIn(self, cred):
    self._oprot.writeMessageBegin('isLoggedIn', TMessageType.CALL, self._seqid)
    args = isLoggedIn_args()
    args.cred = cred
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_isLoggedIn(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = isLoggedIn_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "isLoggedIn failed: unknown result");

  def logoutSession(self, cred):
    """
    Parameters:
     - cred
    """
    self.send_logoutSession(cred)

  def send_logoutSession(self, cred):
    self._oprot.writeMessageBegin('logoutSession', TMessageType.CALL, self._seqid)
    args = logoutSession_args()
    args.cred = cred
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def sendCommand(self, cred, cmd):
    """
    Parameters:
     - cred
     - cmd
    """
    self.send_sendCommand(cred, cmd)

  def send_sendCommand(self, cred, cmd):
    self._oprot.writeMessageBegin('sendCommand', TMessageType.CALL, self._seqid)
    args = sendCommand_args()
    args.cred = cred
    args.cmd = cmd
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def search(self, cred, criteria):
    """
    Parameters:
     - cred
     - criteria
    """
    self.send_search(cred, criteria)
    return self.recv_search()

  def send_search(self, cred, criteria):
    self._oprot.writeMessageBegin('search', TMessageType.CALL, self._seqid)
    args = search_args()
    args.cred = cred
    args.criteria = criteria
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_search(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = search_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "search failed: unknown result");

  def getPlaylists(self, cred):
    """
    Parameters:
     - cred
    """
    self.send_getPlaylists(cred)
    return self.recv_getPlaylists()

  def send_getPlaylists(self, cred):
    self._oprot.writeMessageBegin('getPlaylists', TMessageType.CALL, self._seqid)
    args = getPlaylists_args()
    args.cred = cred
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getPlaylists(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getPlaylists_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getPlaylists failed: unknown result");

  def getPlaylist(self, cred, plist_id):
    """
    Parameters:
     - cred
     - plist_id
    """
    self.send_getPlaylist(cred, plist_id)
    return self.recv_getPlaylist()

  def send_getPlaylist(self, cred, plist_id):
    self._oprot.writeMessageBegin('getPlaylist', TMessageType.CALL, self._seqid)
    args = getPlaylist_args()
    args.cred = cred
    args.plist_id = plist_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getPlaylist(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getPlaylist_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getPlaylist failed: unknown result");

  def getPlaylistByName(self, cred, name):
    """
    Parameters:
     - cred
     - name
    """
    self.send_getPlaylistByName(cred, name)
    return self.recv_getPlaylistByName()

  def send_getPlaylistByName(self, cred, name):
    self._oprot.writeMessageBegin('getPlaylistByName', TMessageType.CALL, self._seqid)
    args = getPlaylistByName_args()
    args.cred = cred
    args.name = name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getPlaylistByName(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getPlaylistByName_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getPlaylistByName failed: unknown result");

  def selectPlaylist(self, cred, playlist):
    """
    Parameters:
     - cred
     - playlist
    """
    self.send_selectPlaylist(cred, playlist)

  def send_selectPlaylist(self, cred, playlist):
    self._oprot.writeMessageBegin('selectPlaylist', TMessageType.CALL, self._seqid)
    args = selectPlaylist_args()
    args.cred = cred
    args.playlist = playlist
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def selectPlaylistById(self, cred, plist_id):
    """
    Parameters:
     - cred
     - plist_id
    """
    self.send_selectPlaylistById(cred, plist_id)

  def send_selectPlaylistById(self, cred, plist_id):
    self._oprot.writeMessageBegin('selectPlaylistById', TMessageType.CALL, self._seqid)
    args = selectPlaylistById_args()
    args.cred = cred
    args.plist_id = plist_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def merge2playlist(self, cred, pl, tracks):
    """
    Parameters:
     - cred
     - pl
     - tracks
    """
    self.send_merge2playlist(cred, pl, tracks)
    return self.recv_merge2playlist()

  def send_merge2playlist(self, cred, pl, tracks):
    self._oprot.writeMessageBegin('merge2playlist', TMessageType.CALL, self._seqid)
    args = merge2playlist_args()
    args.cred = cred
    args.pl = pl
    args.tracks = tracks
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_merge2playlist(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = merge2playlist_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "merge2playlist failed: unknown result");

  def add2playlist(self, cred, pl, track):
    """
    Parameters:
     - cred
     - pl
     - track
    """
    self.send_add2playlist(cred, pl, track)
    return self.recv_add2playlist()

  def send_add2playlist(self, cred, pl, track):
    self._oprot.writeMessageBegin('add2playlist', TMessageType.CALL, self._seqid)
    args = add2playlist_args()
    args.cred = cred
    args.pl = pl
    args.track = track
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add2playlist(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = add2playlist_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "add2playlist failed: unknown result");

  def whats_playing(self, ):
    self.send_whats_playing()
    return self.recv_whats_playing()

  def send_whats_playing(self, ):
    self._oprot.writeMessageBegin('whats_playing', TMessageType.CALL, self._seqid)
    args = whats_playing_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_whats_playing(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = whats_playing_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "whats_playing failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["loginSession"] = Processor.process_loginSession
    self._processMap["isLoggedIn"] = Processor.process_isLoggedIn
    self._processMap["logoutSession"] = Processor.process_logoutSession
    self._processMap["sendCommand"] = Processor.process_sendCommand
    self._processMap["search"] = Processor.process_search
    self._processMap["getPlaylists"] = Processor.process_getPlaylists
    self._processMap["getPlaylist"] = Processor.process_getPlaylist
    self._processMap["getPlaylistByName"] = Processor.process_getPlaylistByName
    self._processMap["selectPlaylist"] = Processor.process_selectPlaylist
    self._processMap["selectPlaylistById"] = Processor.process_selectPlaylistById
    self._processMap["merge2playlist"] = Processor.process_merge2playlist
    self._processMap["add2playlist"] = Processor.process_add2playlist
    self._processMap["whats_playing"] = Processor.process_whats_playing

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_loginSession(self, seqid, iprot, oprot):
    args = loginSession_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = loginSession_result()
    result.success = self._handler.loginSession(args.cred)
    oprot.writeMessageBegin("loginSession", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_isLoggedIn(self, seqid, iprot, oprot):
    args = isLoggedIn_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = isLoggedIn_result()
    result.success = self._handler.isLoggedIn(args.cred)
    oprot.writeMessageBegin("isLoggedIn", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_logoutSession(self, seqid, iprot, oprot):
    args = logoutSession_args()
    args.read(iprot)
    iprot.readMessageEnd()
    self._handler.logoutSession(args.cred)
    return

  def process_sendCommand(self, seqid, iprot, oprot):
    args = sendCommand_args()
    args.read(iprot)
    iprot.readMessageEnd()
    self._handler.sendCommand(args.cred, args.cmd)
    return

  def process_search(self, seqid, iprot, oprot):
    args = search_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = search_result()
    result.success = self._handler.search(args.cred, args.criteria)
    oprot.writeMessageBegin("search", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getPlaylists(self, seqid, iprot, oprot):
    args = getPlaylists_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getPlaylists_result()
    result.success = self._handler.getPlaylists(args.cred)
    oprot.writeMessageBegin("getPlaylists", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getPlaylist(self, seqid, iprot, oprot):
    args = getPlaylist_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getPlaylist_result()
    result.success = self._handler.getPlaylist(args.cred, args.plist_id)
    oprot.writeMessageBegin("getPlaylist", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getPlaylistByName(self, seqid, iprot, oprot):
    args = getPlaylistByName_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getPlaylistByName_result()
    result.success = self._handler.getPlaylistByName(args.cred, args.name)
    oprot.writeMessageBegin("getPlaylistByName", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectPlaylist(self, seqid, iprot, oprot):
    args = selectPlaylist_args()
    args.read(iprot)
    iprot.readMessageEnd()
    self._handler.selectPlaylist(args.cred, args.playlist)
    return

  def process_selectPlaylistById(self, seqid, iprot, oprot):
    args = selectPlaylistById_args()
    args.read(iprot)
    iprot.readMessageEnd()
    self._handler.selectPlaylistById(args.cred, args.plist_id)
    return

  def process_merge2playlist(self, seqid, iprot, oprot):
    args = merge2playlist_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = merge2playlist_result()
    result.success = self._handler.merge2playlist(args.cred, args.pl, args.tracks)
    oprot.writeMessageBegin("merge2playlist", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add2playlist(self, seqid, iprot, oprot):
    args = add2playlist_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add2playlist_result()
    result.success = self._handler.add2playlist(args.cred, args.pl, args.track)
    oprot.writeMessageBegin("add2playlist", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_whats_playing(self, seqid, iprot, oprot):
    args = whats_playing_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = whats_playing_result()
    result.success = self._handler.whats_playing()
    oprot.writeMessageBegin("whats_playing", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class loginSession_args:
  """
  Attributes:
   - cred
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'cred', (SpotifyCredential, SpotifyCredential.thrift_spec), None, ), # 1
  )

  def __init__(self, cred=None,):
    self.cred = cred

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.cred = SpotifyCredential()
          self.cred.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('loginSession_args')
    if self.cred is not None:
      oprot.writeFieldBegin('cred', TType.STRUCT, 1)
      self.cred.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class loginSession_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (SpotifyCredential, SpotifyCredential.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = SpotifyCredential()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('loginSession_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class isLoggedIn_args:
  """
  Attributes:
   - cred
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'cred', (SpotifyCredential, SpotifyCredential.thrift_spec), None, ), # 1
  )

  def __init__(self, cred=None,):
    self.cred = cred

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.cred = SpotifyCredential()
          self.cred.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('isLoggedIn_args')
    if self.cred is not None:
      oprot.writeFieldBegin('cred', TType.STRUCT, 1)
      self.cred.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class isLoggedIn_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('isLoggedIn_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class logoutSession_args:
  """
  Attributes:
   - cred
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'cred', (SpotifyCredential, SpotifyCredential.thrift_spec), None, ), # 1
  )

  def __init__(self, cred=None,):
    self.cred = cred

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.cred = SpotifyCredential()
          self.cred.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('logoutSession_args')
    if self.cred is not None:
      oprot.writeFieldBegin('cred', TType.STRUCT, 1)
      self.cred.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sendCommand_args:
  """
  Attributes:
   - cred
   - cmd
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'cred', (SpotifyCredential, SpotifyCredential.thrift_spec), None, ), # 1
    (2, TType.I32, 'cmd', None, None, ), # 2
  )

  def __init__(self, cred=None, cmd=None,):
    self.cred = cred
    self.cmd = cmd

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.cred = SpotifyCredential()
          self.cred.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.cmd = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sendCommand_args')
    if self.cred is not None:
      oprot.writeFieldBegin('cred', TType.STRUCT, 1)
      self.cred.write(oprot)
      oprot.writeFieldEnd()
    if self.cmd is not None:
      oprot.writeFieldBegin('cmd', TType.I32, 2)
      oprot.writeI32(self.cmd)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class search_args:
  """
  Attributes:
   - cred
   - criteria
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'cred', (SpotifyCredential, SpotifyCredential.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'criteria', (SpotifySearch, SpotifySearch.thrift_spec), None, ), # 2
  )

  def __init__(self, cred=None, criteria=None,):
    self.cred = cred
    self.criteria = criteria

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.cred = SpotifyCredential()
          self.cred.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = SpotifySearch()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('search_args')
    if self.cred is not None:
      oprot.writeFieldBegin('cred', TType.STRUCT, 1)
      self.cred.write(oprot)
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class search_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.STRUCT,(SpotifyTrack, SpotifyTrack.thrift_spec)), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = set()
          (_etype3, _size0) = iprot.readSetBegin()
          for _i4 in xrange(_size0):
            _elem5 = SpotifyTrack()
            _elem5.read(iprot)
            self.success.add(_elem5)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('search_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.STRUCT, len(self.success))
      for iter6 in self.success:
        iter6.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getPlaylists_args:
  """
  Attributes:
   - cred
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'cred', (SpotifyCredential, SpotifyCredential.thrift_spec), None, ), # 1
  )

  def __init__(self, cred=None,):
    self.cred = cred

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.cred = SpotifyCredential()
          self.cred.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getPlaylists_args')
    if self.cred is not None:
      oprot.writeFieldBegin('cred', TType.STRUCT, 1)
      self.cred.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getPlaylists_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.STRING,None), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = set()
          (_etype10, _size7) = iprot.readSetBegin()
          for _i11 in xrange(_size7):
            _elem12 = iprot.readString();
            self.success.add(_elem12)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getPlaylists_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.STRING, len(self.success))
      for iter13 in self.success:
        oprot.writeString(iter13)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getPlaylist_args:
  """
  Attributes:
   - cred
   - plist_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'cred', (SpotifyCredential, SpotifyCredential.thrift_spec), None, ), # 1
    (2, TType.I32, 'plist_id', None, None, ), # 2
  )

  def __init__(self, cred=None, plist_id=None,):
    self.cred = cred
    self.plist_id = plist_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.cred = SpotifyCredential()
          self.cred.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.plist_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getPlaylist_args')
    if self.cred is not None:
      oprot.writeFieldBegin('cred', TType.STRUCT, 1)
      self.cred.write(oprot)
      oprot.writeFieldEnd()
    if self.plist_id is not None:
      oprot.writeFieldBegin('plist_id', TType.I32, 2)
      oprot.writeI32(self.plist_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getPlaylist_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.STRUCT,(SpotifyTrack, SpotifyTrack.thrift_spec)), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = set()
          (_etype17, _size14) = iprot.readSetBegin()
          for _i18 in xrange(_size14):
            _elem19 = SpotifyTrack()
            _elem19.read(iprot)
            self.success.add(_elem19)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getPlaylist_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.STRUCT, len(self.success))
      for iter20 in self.success:
        iter20.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getPlaylistByName_args:
  """
  Attributes:
   - cred
   - name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'cred', (SpotifyCredential, SpotifyCredential.thrift_spec), None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
  )

  def __init__(self, cred=None, name=None,):
    self.cred = cred
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.cred = SpotifyCredential()
          self.cred.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getPlaylistByName_args')
    if self.cred is not None:
      oprot.writeFieldBegin('cred', TType.STRUCT, 1)
      self.cred.write(oprot)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getPlaylistByName_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.STRUCT,(SpotifyTrack, SpotifyTrack.thrift_spec)), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = set()
          (_etype24, _size21) = iprot.readSetBegin()
          for _i25 in xrange(_size21):
            _elem26 = SpotifyTrack()
            _elem26.read(iprot)
            self.success.add(_elem26)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getPlaylistByName_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.STRUCT, len(self.success))
      for iter27 in self.success:
        iter27.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectPlaylist_args:
  """
  Attributes:
   - cred
   - playlist
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'cred', (SpotifyCredential, SpotifyCredential.thrift_spec), None, ), # 1
    (2, TType.STRING, 'playlist', None, None, ), # 2
  )

  def __init__(self, cred=None, playlist=None,):
    self.cred = cred
    self.playlist = playlist

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.cred = SpotifyCredential()
          self.cred.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.playlist = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectPlaylist_args')
    if self.cred is not None:
      oprot.writeFieldBegin('cred', TType.STRUCT, 1)
      self.cred.write(oprot)
      oprot.writeFieldEnd()
    if self.playlist is not None:
      oprot.writeFieldBegin('playlist', TType.STRING, 2)
      oprot.writeString(self.playlist)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectPlaylistById_args:
  """
  Attributes:
   - cred
   - plist_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'cred', (SpotifyCredential, SpotifyCredential.thrift_spec), None, ), # 1
    (2, TType.I32, 'plist_id', None, None, ), # 2
  )

  def __init__(self, cred=None, plist_id=None,):
    self.cred = cred
    self.plist_id = plist_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.cred = SpotifyCredential()
          self.cred.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.plist_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectPlaylistById_args')
    if self.cred is not None:
      oprot.writeFieldBegin('cred', TType.STRUCT, 1)
      self.cred.write(oprot)
      oprot.writeFieldEnd()
    if self.plist_id is not None:
      oprot.writeFieldBegin('plist_id', TType.I32, 2)
      oprot.writeI32(self.plist_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class merge2playlist_args:
  """
  Attributes:
   - cred
   - pl
   - tracks
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'cred', (SpotifyCredential, SpotifyCredential.thrift_spec), None, ), # 1
    (2, TType.STRING, 'pl', None, None, ), # 2
    (3, TType.SET, 'tracks', (TType.STRUCT,(SpotifyTrack, SpotifyTrack.thrift_spec)), None, ), # 3
  )

  def __init__(self, cred=None, pl=None, tracks=None,):
    self.cred = cred
    self.pl = pl
    self.tracks = tracks

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.cred = SpotifyCredential()
          self.cred.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.pl = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.SET:
          self.tracks = set()
          (_etype31, _size28) = iprot.readSetBegin()
          for _i32 in xrange(_size28):
            _elem33 = SpotifyTrack()
            _elem33.read(iprot)
            self.tracks.add(_elem33)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('merge2playlist_args')
    if self.cred is not None:
      oprot.writeFieldBegin('cred', TType.STRUCT, 1)
      self.cred.write(oprot)
      oprot.writeFieldEnd()
    if self.pl is not None:
      oprot.writeFieldBegin('pl', TType.STRING, 2)
      oprot.writeString(self.pl)
      oprot.writeFieldEnd()
    if self.tracks is not None:
      oprot.writeFieldBegin('tracks', TType.SET, 3)
      oprot.writeSetBegin(TType.STRUCT, len(self.tracks))
      for iter34 in self.tracks:
        iter34.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class merge2playlist_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('merge2playlist_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add2playlist_args:
  """
  Attributes:
   - cred
   - pl
   - track
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'cred', (SpotifyCredential, SpotifyCredential.thrift_spec), None, ), # 1
    (2, TType.STRING, 'pl', None, None, ), # 2
    (3, TType.STRUCT, 'track', (SpotifyTrack, SpotifyTrack.thrift_spec), None, ), # 3
  )

  def __init__(self, cred=None, pl=None, track=None,):
    self.cred = cred
    self.pl = pl
    self.track = track

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.cred = SpotifyCredential()
          self.cred.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.pl = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.track = SpotifyTrack()
          self.track.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add2playlist_args')
    if self.cred is not None:
      oprot.writeFieldBegin('cred', TType.STRUCT, 1)
      self.cred.write(oprot)
      oprot.writeFieldEnd()
    if self.pl is not None:
      oprot.writeFieldBegin('pl', TType.STRING, 2)
      oprot.writeString(self.pl)
      oprot.writeFieldEnd()
    if self.track is not None:
      oprot.writeFieldBegin('track', TType.STRUCT, 3)
      self.track.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add2playlist_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add2playlist_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class whats_playing_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('whats_playing_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class whats_playing_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (SpotifyTrack, SpotifyTrack.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = SpotifyTrack()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('whats_playing_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
