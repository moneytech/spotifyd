// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <protocol/TBinaryProtocol.h>
#include <server/TSimpleServer.h>
#include <transport/TServerSocket.h>
#include <transport/TBufferTransports.h>

#include "Spotify.h"

//I don't believe these headers are C++ ready....
extern "C" {
	#include <libspotify/api.h>
	#include "audio.h"
}

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

//Global pointer to Spotify Handler. Used by callbacks.
static SpotifyHandler * g_handler = NULL;

/* --- Data --- */
extern const uint8_t g_appkey[];
extern const size_t g_appkey_size;



static sp_playlist_callbacks pl_callbacks;

//nice per session wrapper class
//
class SpotifySession {
public:
	SpotifySession() 
		 :m_notify_do(0)
		 ,m_playback_done(1)
		 ,m_pc(NULL) //playlist container
		 ,m_jukeboxlist(NULL)
		 ,m_remove_tracks(0)
		 ,m_currenttrack(0)
		 ,m_track_idx(-1){
			 //
			 m_sess = new sp_session;
		 }

	sp_session * getSession(void) {
		return m_sess;
	}
	int playback_done(void) {
		return m_playback_done;
	}
	sp_playlist * getActivePlaylist(void) {
		return m_jukeboxlist;
	}
	sp_playlistcontainer * getPlaylistContainer(void) {
		if(!m_sess) {
			return NULL;
		}
		return sp_session_playlistcontainer(m_sess);
	}
	void setPlaylist(sp_playlist * pl) {
		if(pl) {
			m_jukeboxlist = pl;
		}
	}

	std::string getPlaylistName(void) {
		if(m_jukeboxlist) {
			return std::string("");
		}

		return std::string(sp_playlist_name(m_jukeboxlist));
	}

	sp_track * setCurrentTrack(int idx) {
#define NOTRACK -1
		if( idx < 0 ) {
			m_track_idx = idx;
			m_currenttrack = NULL;
			return NULL;
		}

		sp_track * t = NULL;
		int n_tracks = 0;

		if(!m_jukeboxlist) {
			return NULL;
		}

		n_tracks = sp_playlist_num_tracks(m_jukeboxlist);
		if(!n_tracks || n_tracks < idx) {
			return NULL;
		}

		sp_track * t = sp_playlist_track(m_jukeboxlist, idx);
		m_currenttrack = t;
		m_track_idx = idx;
		
		return t;
	
	}

	sp_track * getCurrentTrack() {
		return m_currenttrack;
	
	}
	
	int getCurrentTrackIdx() {
		return m_track_idx;
	}
#if 0
	void selectPlaylist(const SpotifyCredential& cred, const std::string& playlist) {
		// Your implementation goes here
		printf("selectPlaylist\n");
	}
#endif
private:
	sp_session *m_sess;
	int m_notify_do;
	int m_playback_done;
	sp_playlist *m_jukeboxlist;
	int m_remove_tracks;
	sp_track *m_currenttrack;
	int m_track_idx;


}

//forward declaration.
static sp_session_callbacks session_callbacks;

//move elsewhere.
class Lockable {
public:
	Lockable() {
		//
	}
	void lock() {
		pthread_mutex_unlock(&m_notify_mutex);
	}

	void cond_signal() {
		pthread_cond_signal(&g_notify_cond);
	}

	void unlock() {
		pthread_mutex_unlock(&m_notify_mutex);
	}

private:
	pthread_mutex_t m_notify_mutex;
	pthread_cond_t m_notify_cond;
}

// This baby here, the SpotifyHandler, should be a singleton. The main reason
// for this is the fact that we can only have one audio queue, and we only need one
// handler for incoming thrift requests. If we've got several  ongoing spotify 
// sessions for different users, the idea is to randomly play music from each of 
// their 'selected' playlists. 
//
// For example: if Joe is listening to his Hip Hop playist, and Jane is listening
// to her oldies playlists. We *do not* want several instances of the SpotifyHandler
// created. We don't need them either. The Handler will randomly select tracks from
// each of the users registered. The Audio Queue must be a singleton, and so we 
// can make the entire handler singleton. One instance is enough to handler all
// incoming requests.
//
class SpotifyHandler : virtual public SpotifyIf, private Lockable {
public:
	static SpotifyHandler * getInstance() {
		if(!m_handler_ptr) {
			m_handler_ptr = new SpotifyHandler:
		}
		return m_handler_ptr;
	};

	void initiateSession(SpotifyCredential& _return, const SpotifyCredential& cred) {
		// Your implementation goes here
		printf("initiatingSession\n");

		shared_ptr< SpotifySession > sess = getSession(cred);
		if(!sess) {
			sess = shared_ptr< spotifySession>(new SpotifySession());
			sp_session_login(sess->getSession(), cred.username, cred.passwd, 0);

			//are SpotifyCredentials hashable? 
			m_sessions.insert( cred, sess)
		}
		
		//do we need to do anything else? Load playlsits or whatever?
		//callback should handle that.
	}

	void logoutSession(const SpotifyCredential& cred) {
		// Your implementation goes here
		printf("logoutSession\n");
	}

	void sendCommand(const SpotifyCredential& cred, const SpotifyCmd::type cmd) {
		// Your implementation goes here
		printf("sendCommand\n");

		switch(cmd){
		case SpotifyCmd::PLAY:
			break;
		case SpotifyCmd::PAUSE:
			break;
		case SpotifyCmd::NEXT:
			break;
		case SpotifyCmd::PREV:
			break;
		case SpotifyCmd::RAND:
			break;
		case SpotifyCmd::LINEAR:
			break;
		case SpotifyCmd::REPEAT_ONE:
			break;
		case SpotifyCmd::REPEAT:
			break;
		default:
		break;
		}
	}

	void switchSession() {
		//change session, allow it to be played.
	}

	void tracks_added_cb(sp_playlist *pl, sp_track * const *tracks,
			int num_tracks, int position, void *userdata) {
		shared_ptr<SpotifySession> sess = getActiveSession();
		if(!sess) {
			return;
		}

		if (pl != sess->getActivePlaylist())
		{
			return;
		}

		printf("jukebox: %d tracks were added\n", num_tracks);
		fflush(stdout);
		//try_jukebox_start();
	}

	void tracks_removed_cb(sp_playlist *pl, const int *tracks,
			int num_tracks, void *userdata) {
		int i, k = 0;

		shared_ptr<SpotifySession> sess = getActiveSession();
		if(!sess) {
			return;
		}

		if (pl != sess->getActivePlaylist())
		{
			return;
		}

		int track_idx = sess->getCurrentTrackIdx();
		for (i = 0; i < num_tracks; ++i)
		{
			if (tracks[i] < track_idx)
			{
				++k;
			}
		}

		track_idx -= k;
		sess->setCurrentTrack(track_idx);

		fflush(stdout);
		//try_jukebox_start();
	}

	void tracks_moved_cb(sp_playlist *pl, const int *tracks,
			int num_tracks, int new_position, void *userdata) {
		shared_ptr<SpotifySession> sess = getActiveSession();
		if(!sess) {
			return;
		}

		if (pl != sess->getActivePlaylist())
		{
			return;
		}

		printf("jukebox: %d tracks were moved around\n", num_tracks);
		fflush(stdout);

		//try_jukebox_start();
	}

	void playlist_renamed_cb(sp_playlist *pl, void *userdata) {
		const char *name = sp_playlist_name(pl);
		const char *current = NULL;

		shared_ptr<SpotifySession> sess = getActiveSession();
		if(!sess) {
			return;
		}
		currentpl = sp_playlist_name(sess->getActivePlaylist());

		if (!strcasecmp(name, currentpl)) 
		{
			sess->setActivePlaylist(pl);
			sess->setCurrentTrack(0);
			//try_jukebox_start();

		} else if (sess->getActivePlaylist() == pl) {
			printf("jukebox: current playlist renamed to \"%s\".\n", name);
			sess->setActivePlaylist(NULL);
			sess->setCurrentTrack(NOTRACK);
			//sp_session_player_unload(g_sess);
		}
	}

	void logged_in_cb(sp_session *sess, sp_error error) {
		//get the session from the session list...
		//
		//Need to store those in the handler, fo sho.


		sp_playlistcontainer *pc = sp_session_playlistcontainer(sess);
		int i;

		if (SP_ERROR_OK != error) 
		{
			fprintf(stderr, "jukebox: Login failed: %s\n",
					sp_error_message(error));
			exit(2);
		}

		printf("jukebox: Looking at %d playlists\n", sp_playlistcontainer_num_playlists(pc));

		for (i = 0; i < sp_playlistcontainer_num_playlists(pc); ++i)
		{
			//we add the playlists to the list. Select the user's playlist as well.
			sp_playlist *pl = sp_playlistcontainer_playlist(pc, i);
			sp_playlist_add_callbacks(pl, &pl_callbacks, NULL);

		}

	}

	void end_of_track_cb(sp_session *sess) {
		lock();
		m_playback_done = 1;
		//h->setPlaybackState(DONE);
		h->switchSession();
		cond_signal();
		unlock();
	}

	void play_token_lost_cb(sp_session *sess)
	{
		audio_fifo_flush(&m_audiofifo);

		//Find the session and stop it.
		shared_ptr<SpotifySession> spsession = getActiveSession();

		if (spsession->getCurrentTrack() != NULL)
		{
			// unload the session that caused the token loss.
			sp_session_player_unload(sess);
			spsession->setCurrentTrack(NO_TRACK);
		}
		switchSession():
	}

	int music_delivery_cb(sp_session *sess, const sp_audioformat *format,
                                  const void *frames, int num_frames)
	{
		size_t s;
		audio_fifo_data_t *afd;

		if (num_frames == 0)
		{
			return 0; // Audio discontinuity, do nothing
		}

		pthread_mutex_lock(&m_audiofifo->mutex);

		/* Buffer one second of audio */
		if (af->qlen > format->sample_rate)
		{
			pthread_mutex_unlock(&m_audiofifo->mutex);
			return 0;
		}

		s = num_frames * sizeof(int16_t) * format->channels;

		afd = malloc(sizeof(audio_fifo_data_t) + s);
		memcpy(afd->samples, frames, s);

		afd->nsamples = num_frames;
		afd->rate = format->sample_rate;
		afd->channels = format->channels;

		TAILQ_INSERT_TAIL(&m_audiofifo->q, afd, link);
		m_audiofifo->qlen += num_frames;

		pthread_cond_signal(&m_audiofifo->cond);
		pthread_mutex_unlock(&m_audiofifo->mutex);

		return num_frames;
	}


	void search(SpotifyPlaylist& _return, const SpotifyCredential& cred, const SpotifySearch& criteria) {
		// Your implementation goes here
		printf("search\n");
		shared_ptr< sp_session > sess = getSession(cred);
		if(!sess) {
			sess = shared_ptr< SpotifySessuib>(new SpotifySession());
			sp_session_login(sess, cred.username, cred.passwd, 0);

			// Write a SpotifyCredentials hashing function?
			sessions.insert( cred, sess)
		}
	}

	void getPlaylists(SpotifyPlaylistList& _return, const SpotifyCredential& cred) 
	{
		printf("getPlaylists\n");
		shared_ptr< SpotifySession > sess = getSession(cred);
		if(!sess) {
			return;
		}
		sp_playlistcontainer * pc = sess->getPlaylistContainer();
		if(!pc) {
			return;
		}

		for (int i = 0; i < sp_playlistcontainer_num_playlists(pc); ++i)
		{
			sp_playlist *pl = sp_playlistcontainer_playlist(pc, i);

			std::string s_pl(sp_playlist_name(pl));
			_return.insert(*s_pl);
		}

		return;

	}

	void getPlaylist(SpotifyPlaylist& _return, const SpotifyCredential& cred, const int32_t plist_id) {
		// Your implementation goes here
		printf("getPlaylist\n");
		
		shared_ptr< SpotifySession > sess = getSession(cred);
		if(!sess) {
			return;
		}

		sp_playlistcontainer * pc = sess->getPlaylistContainer();
		if(!pc) {
			return;
		}

		sp_playlist *pl = sp_playlistcontainer_playlist(pc, plist_id);

		if(!pl) {
			return;
		}

		for(int j = 0 ; j < sp_playlist_num_tracks(pl) ; j++ ) {
			sp_track * t = sp_playlist_track(pl, j);
			int duration = sp_track_duration(t); //millisecs?
			shared_ptr<SpotifyTrack> spt(
					new SpotifyTrack(
						, sp_track_name(t)
						, sp_artist_name(sp_track_artist(t, 0) )
						, (duration / 60000 )
						, ((duration / 1000) % 60)
						, sp_track_popularity(t)
						, NULL //TODO: genre
						, sp_track_is_starred(t)));
			_return.insert(*spt);


		}

		return;
	}

	void getPlaylistByName(SpotifyPlaylist& _return, const SpotifyCredential& cred, const std::string& name) {
		// Your implementation goes here
		printf("getPlaylistByName\n");
		
		shared_ptr< SpotifySession > sess = getSession(cred);
		if(!sess) {
			return;
		}


		sp_playlistcontainer * pc = sess->getPlaylistContainer();
		if(!pc) {
			return;
		}

		for (int i = 0; i < sp_playlistcontainer_num_playlists(pc); ++i) {
			sp_playlist *pl = sp_playlistcontainer_playlist(pc, i);

			if(!pl) {
				continue;
			}

			std::string plname(sp_playlist_name(pl));
			if(plname.equals(name)) {
				getPlaylist(_return, cred, i);
				break;
			}

		}
		return;
	}

	void selectPlaylist(const SpotifyCredential& cred, const std::string& playlist) {
		// Your implementation goes here
		printf("selectPlaylist\n");
		shared_ptr< SpotifySession > sess = getSession(cred);
		if(!sess) {
			return;
		}


		sp_playlistcontainer * pc = sess->getPlaylistContainer();
		if(!pc) {
			return;
		}

		//O(n) ugly, but this is really the libspotify way of doing it :(
		for (int i = 0; i < sp_playlistcontainer_num_playlists(pc); ++i) {
			sp_playlist *pl = sp_playlistcontainer_playlist(pc, i);

			if(!pl) {
				continue;
			}

			std::string plname(sp_playlist_name(pl));
			if(plname.equals(name)) {
				setPlaylist(pl);
				break;
			}
		}
	}

	bool merge2playlist(const SpotifyCredential& cred, const std::string& pl, const SpotifyPlaylist& tracks) {
		// Your implementation goes here
		printf("merge2playlist\n");
	}

	bool add2playlist(const SpotifyCredential& cred, const std::string& pl, const SpotifyTrack& track) {
		// Your implementation goes here
		printf("add2playlist\n");
	}

	void whats_playing(SpotifyTrack& _return) {
		// Your implementation goes here
		printf("whats_playing\n");
	}

private:
	SpotifyHandler(const uint8_t *appkey, const size_t appkey_size) 
		: Lockable() {
		//private so it can't be called.
		spconfig = {
			.api_version = SPOTIFY_API_VERSION,
			.cache_location = "tmp",
			.settings_location = "tmp",
			.application_key = g_appkey,
			.application_key_size = 0, // Set in main()
			.user_agent = "spotifyd",
			.callbacks = &session_callbacks,
			NULL,
		};
	}

	shared_ptr<SpotifySession> getSession(SpotifyCredential& cred) {
		typedef session_map::const_iterator cspit;
		cspit it;
		if(im_sessions.find(cred) == it.end())
		{
			return NULL;
		}

		return *it.second;

	}
	//we also need to be able to search by sp_session, that's quite important; callbacks rely very heavily
	//on it.
	typedef std::map< shared_ptr<SpotifyCredential>, shared_ptr<SpotifySession> > session_map;

	sp_playlistcontainer * getPlaylistContainer(SpotifyCredential& cred) {
		shared_ptr<SpotifySession> sess = getSession(cred);
		if(!sess) {
			return NULL;
		}

		return sp_session_playlistcontainer(sess.getSession());
	}

	m_sessions& sessions() {
		return m_sessions;
	}

	audio_fifo_t * audio_fifo() {
		return &m_audiofifo;
	}

	sp_session_config * app_config() {
		return &m_spconfig;
	}

	//libspotify wrapped
	sp_session_config m_spconfig;
	audio_fifo_t m_audiofifo;

	//proper members
	session_map m_sessions;
	shared_ptr<SpotifySession> m_active_session;
	SpotifyHandler * m_handler_ptr = NULL;

};

/* --------------------------  PLAYLIST CALLBACKS  ------------------------- */
static void tracks_added(sp_playlist *pl, sp_track * const *tracks,
		int num_tracks, int position, void *userdata)
{
	if(!g_handler) {
		return;
	}

	return g_handler->tracks_added_cb(pl, tracks, num_tracks, position, userdata);
}

static void tracks_removed(sp_playlist *pl, const int *tracks,
		int num_tracks, void *userdata)
{
	if(!g_handler) {
		return;
	}

	return g_handler->tracks_removed_cb(pl, tracks, num_tracks, userdata);
}

static void tracks_moved(sp_playlist *pl, const int *tracks,
		int num_tracks, int new_position, void *userdata)
{
	if(!g_handler) {
		return;
	}

	return g_handler->tracks_moved_cb(pl, tracks, num_tracks, newposition, userdata);
}

static void playlist_renamed(sp_playlist *pl, void *userdata)
{
	if(!g_handler) {
		return;
	}

	return g_handler->playlist_renamed_cb(pl, userdata);
}

pl_callbacks = {
	.tracks_added = &tracks_added,
	.tracks_removed = &tracks_removed,
	.tracks_moved = &tracks_moved,
	.playlist_renamed = &playlist_renamed,
};


/* --------------------------  SESSION CALLBACKS  ------------------------- */
static void logged_in(sp_session *sess, sp_error error) {

	if(!g_handler) {
		return;
	}

	return g_handler->logged_in_cb(sess, error);
}

static void play_token_lost(sp_session *sess) {
	if(!g_handler) {
		return;
	}

	return g_handler->play_token_lost_cb(sess);
}

#define STOP 0
#define PLAY 1
#define DONE 2
void end_of_track(sp_session * sess) {
	if(!g_handler) {
		return;
	}

	return g_handler->end_of_track_cb(sess);

}

//I would honestly love to avoid mallocs...
//
//when one session is playing all other sessions must be mute.
//
static int music_delivery(sp_session *sess, const sp_audioformat *format,
                                  const void *frames, int num_frames)
{
	if(!g_handler) {
		return;
	}

	return g_handler->music_delivery_cb(sess, format, frames, num_frames);
}

session_callbacks = {
        .logged_in = &logged_in,
        .notify_main_thread = &notify_main_thread,
        .music_delivery = &music_delivery,
        .metadata_updated = &metadata_updated,
        .play_token_lost = &play_token_lost,
        .log_message = NULL,
        .end_of_track = &end_of_track,
};


int main(int argc, char **argv) {
	int port = 9090;

	g_handler = new SpotifyHandler(g_appkey, g_appket_size);
	shared_ptr<SpotifyHandler> handler(g_handler);

	shared_ptr<TProcessor> processor(new SpotifyProcessor(handler));
	shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
	shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
	shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

	TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
	server.serve();
	return 0;
}

